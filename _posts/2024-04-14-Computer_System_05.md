---
layout: single

title:  "컴퓨터시스템 03: 기계 수준 프로그래밍 3: 프로시저"

categories: Paper

tag: [Computer, System, Assembly]

typora-root-url: ../

toc: true

author_profile: false

sidebar:
    nav: "docs"

# search: false
use_math: true
---

**글에 들어가기 앞서...**

이 포스팅은 서울시립대학교 인공지능학과 백형부 교수님의 '**컴퓨터시스템**' 강좌의 중간고사 이전 범위 수업 내용에 대한 정리를 담고 있습니다.



수업 자료 출처: ***Bryant and O'Hallaron, Computer Systems: A Programmer's Perspective, 3rd Edition***







# 기계 수준 프로그래밍 III: 프로시저

프로그래밍에서 함수와 프로시저는 겉보기에 상당히 유사해 보이며, 실제로 많은 경우 그 구분이 크게 중요하지 않을 수 있습니다. 함수는 결과값을 반환하는 특징을 가지고 있으며, 프로시저는 반환값이 없이 일련의 작업을 수행하는데 그 목적이 있습니다. 이런 차이에도 불구하고, 두 개념은 종종 서로 교환 가능하게 사용될 수 있으며, 프로그램의 구현에 있어 큰 차이를 만들어내지 않는 경우가 많습니다.

하지만, 이런 미묘한 차이를 명확히 이해하는 것은 여전히 중요합니다. 이유는, 프로그래밍 언어의 구문과 의미론을 정확하게 파악하고, 더 정교하고 효율적인 코드를 작성하는 데 있어 필수적인 기반이 되기 때문입니다. 함수와 프로시저의 구분은 특히, 다양한 프로그래밍 패러다임과 언어에서 각기 다른 방식으로 구현되고 활용되기 때문에, 이를 정확히 아는 것이 프로그래머로서의 유연성과 깊이 있는 이해를 높이는 데 도움이 될 수 있습니다. 



<img src="/images/2024-04-14-Computer_System_05/image-20240414194916471.png" alt="image-20240414194916471" style="zoom:50%;" />

프로시저가 프로그램 내에서 실행될 때, 고려해야 할 여러 요소들이 있습니다. 첫째로, 프로그램의 제어 흐름을 관리해야 합니다. 이는 프로그램 카운터인 `%rip`(Instruction Pointer)가 다음에 실행할 명령어를 가리키도록 변경되어야 함을 의미합니다. 프로시저가 시작될 때는 `%rip`가 프로시저의 첫 번째 명령어를 가리키도록 설정되고, 프로시저가 종료되면 다시 메인 함수 또는 호출한 함수의 다음 명령어로 `%rip`가 올바르게 설정되어야 합니다.

데이터 전달도 중요한 과정입니다. 프로시저가 실행될 때 필요한 데이터는 레지스터를 통해 전달될 수 있으며, 프로시저의 결과 역시 레지스터를 통해 반환됩니다. 이 과정에서 호출하는 측과 호출되는 측 사이의 데이터 전달 방식을 명확히 정의해야 합니다.

메모리 관리도 중요한 요소입니다. 프로시저 내부에서 지역 변수가 선언되면, 이 변수들을 저장하기 위한 메모리 공간이 필요합니다. 이러한 지역 변수들은 주로 스택에 저장되며, 프로시저가 종료되면 이 사용된 메모리는 반환되어야 합니다. 이 과정은 메모리의 효율적 사용과 프로그램의 안정성을 보장하는 데 있어 중요합니다.

마지막으로, 프로시저 호출 시 발생할 수 있는 부수적인 상황들, 예를 들어 레지스터의 값이 변경되는 것을 방지하기 위한 레지스터의 저장 및 복원 같은 작업도 고려해야 합니다. 이는 프로시저가 실행되는 동안 원래의 프로그램 상태를 보존하고, 프로시저 종료 후 원활한 프로그램 실행을 위해 필요합니다.

이 모든 요소들이 구체적으로 어떻게 이루어지는지 자세하게 살펴보도록 하겠습니다.





## 스택 구조

<img src="/images/2024-04-14-Computer_System_05/image-20240414195726936.png" alt="image-20240414195726936" style="zoom:50%;" />

위 설명은 컴퓨터 메모리의 주요 구성 요소 중 하나인 스택 구조에 관한 것입니다. 스택은 특이하게도 **바닥 부분이 가장 큰 주소 값을 가지며, 꼭대기 부분이 가장 작은 주소 값을 가집니다.** `%rsp`는 현재 스택의 꼭대기를 가리키는 레지스터로, 스택에 데이터가 추가되거나 제거될 때마다 `%rsp`의 값이 갱신됩니다. 



<img src="/images/2024-04-14-Computer_System_05/image-20240414200157218.png" alt="image-20240414200157218" style="zoom:50%;" />

데이터가 스택에 푸시(push)될 때는 `%rsp`가 감소하고(주소 값이 작아짐), 팝(pop)될 때는 `%rsp`가 증가합니다(주소 값이 커짐). 이러한 방식으로 `%rsp`는 스택의 현재 상태를 정확히 반영하며, 스택 기반의 데이터 관리와 프로시저 호출에서 중요한 역할을 수행합니다.



## Calling Conventions



### 제어 흐름 변경

<img src="/images/2024-04-14-Computer_System_05/tte.gif" alt="tte" style="zoom:30%;" />

메인 프로세스에서 함수(프로시저)를 호출할 때, 현재 실행 중인 프로그램이 다음에 실행해야 할 명령어의 주소를 스택에 저장합니다. 이후, 프로시저의 시작 주소를 프로그램 카운터인 `%rip` 레지스터에 저장함으로써 프로시저의 명령어를 실행하게 됩니다. 프로시저의 실행이 완료되고 반환될 때는, 스택에서 이전에 저장해 두었던 주소를 팝하여 `rip`에 다시 할당함으로써 메인 프로세스의 실행을 중단했던 지점부터 명령어를 계속해서 읽어나가게 됩니다.



### 데이터 전달

<img src="/images/2024-04-14-Computer_System_05/image-20240414210743040.png" alt="image-20240414210743040" style="zoom:50%;" />

위 어셈블리 코드는 메인 함수와 프로시저 간에 레지스터를 통한 데이터 전달 방식을 보여주는 예시입니다. 각 레지스터 별로 정해진 규약에 따라 데이터가 전달되는 것을 확인할 수 있습니다.



### 지역 데이터 관리

코드가 재진입 가능(Reentrant)하다는 것은, 함수가 전달 인자와 지역 변수를 사용하더라도, 함수를 호출할 때마다 그 상태가 독립적이라는 의미입니다. 즉, 동일한 함수가 동시에 여러 위치에서 호출되어도 각 호출이 서로의 실행에 영향을 주지 않습니다. 이러한 독립성은 함수 호출 시 사용하는 스택의 별도 영역, 즉 프레임(Frame)을 통해 관리됩니다.



![tt3](/images/2024-04-14-Computer_System_05/tt3.gif)

프레임의 범위는 `rsp`(스택 포인터)와 `rbp`(베이스 포인터) 레지스터를 통해 정의됩니다. 여기서 `rsp`는 항상 필요하며, 스택의 현재 위치를 나타냅니다. 반면, `rbp`의 사용은 필수적이지 않으나, 함수 호출 시 스택 프레임의 기준점으로 활용되어 프로그램의 가독성과 디버깅을 용이하게 합니다.





