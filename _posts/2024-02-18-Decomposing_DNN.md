---
layout: single

title:  "On Decomposing a Deep Neural Network into Modules"

categories: Paper

tag: [CNN, decomposing, replaceable, reusable]

typora-root-url: ../

toc: true

author_profile: false

sidebar:
    nav: "docs"

# search: false
use_math: true
---



#### 글에 들어가기 앞서..

이 포스팅은 '***On Decomposing a Deep Neural Network into Modules***' 논문에 대한 소개를 담고 있습니다.



논문 원본은 아래의 링크를 통해 확인할 수 있습니다.

- <https://dl.acm.org/doi/pdf/10.1145/3368089.3409668>





## 배경

딥러닝은 현대 소프트웨어 시스템에서 광범위하게 활용되고 있는 강력한 도구입니다. 딥러닝 이전의 소프트웨어 개발자들은 프로그램을 여러 모듈로 나누어 개발하는 능력을 가지고 있으며, 이러한 능력 덕분에 소프트웨어 개발 속도를 크게 향상시킬 수 있었습니다. 반면, 딥러닝을 사용한 인공지능 모델은 이런 방식이 적용되기 어렵습니다. 이는 인공지능 모델이 대체로 하나의 전체로 작동하기 때문입니다. 



![Handwritten Digit Recognition — mxnet documentation](https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/mlp_mnist.png)

- 그림 출처: <https://mxnet.apache.org/versions/1.5.0/tutorials/python/mnist.html>

  

| 클래스 | 모델 1의 정확도 | 모델 2의 정확도 |
| :----: | :-------------: | :-------------: |
|   0    |       92%       |       82%       |
|   1    |       94%       |       85%       |
|   2    |       89%       |       83%       |
|   3    |       30%       |       81%       |
|   4    |       91%       |       84%       |
|   5    |       88%       |       79%       |
|   6    |       93%       |       87%       |
|   7    |       90%       |       88%       |
|   8    |       87%       |       80%       |
|   9    |       92%       |       86%       |

MNIST 분류 작업을 수행하는 두 개의 모델을 가지고 있는 상황에서, 하나의 모델은 대부분의 클래스에 대해서는 90%에 육박하는 매우 높은 정확도를 보이지만, 3번 클래스에 대해서만 정확도가 낮은 현상을 겪고 있습니다. 반면, 다른 모델은 모든 클래스에 걸쳐 80% 정도의 균일한 정확도를 보입니다. 이런 상황에서 **모델 1**의 3번 클래스에 대한 정확도를 올리기 위한 방법들엔 어떤 것들이 있을까요?

**모델 1**의 3번 클래스에 대한 정확도를 향상시키기 위해 고려할 수 있는 방법은 여러 가지가 있을 수 있지만, 가장 직관적이고 효과적인 방법 중 하나는 해당 클래스에 해당되는 데이터를 더 많이 학습시키는 것입니다. 이 방법은 모델이 3번 클래스의 다양한 특징과 변형을 더 잘 이해하고 학습할 수 있게 해주어, 그 결과 정확도를 크게 향상시킬 수 있습니다.

이건 우리가 가장 자주 사용하는 방법이고, 또 좋은 방법입니다. 그런데 실은 특정 클래스에 해당되는 데이터를 더 많이 학습시키는 방법 외에, 모델의 성능을 끌어올릴 수 있는 다른 방법이 사실상 없습니다. **모델 2**를 학습하는 데에 많은 시간, 컴퓨팅 리소스, 그리고 전력을 투자했음에도 이를 활용하지 못한다면 이는 분명 아쉬운 일입니다. **모델 2**가 3번 클래스 분류에서 보여준 능력을 **모델 1**에 활용할 수 있다면, 분명 큰 가치를 창출할  수 있을 것입니다. 본 논문에서는 바로 그를 위한 방법론을 소개합니다.





## 핵심 아이디어

이 논문에서는 **DNN 모델을 분해(Decomposition)하는 방법**을 소개합니다. DNN 모델을 대체 어떻게 분해한다는 걸까요?



### 분해

딥 뉴럴 네트워크(DNN) 모델을 분해하는 방법에는 주로 두 가지 접근 방식이 있습니다.



![img](/images/2024-02-18-Decomposing_DNN/1*PLMi2pXx4sfykEdypJKQNQ.png)

- 그림 출처: <https://medium.com/@nkrishnan.laksh/transfer-learning-for-object-detection-a499b7bdd12b>

**첫 번째 방식은 정보의 흐름을 따라 모델을 각 단계별로 분해하는 것입니다.** 이 방법은 상대적으로 간단하며, 모델을 레이어 단위로 분해하면 됩니다. 각 레이어는 자체적으로 파라미터를 가지고 있기 때문에, 이러한 분해 과정은 직관적이며 복잡하지 않습니다. 이렇게 분해된 모델의 부분을 활용하는 대표적인 방법이 바로 '전이학습'입니다. 전이학습은 사전에 학습된 모델의 일부를 새로운 모델에 적용하여 학습 시간을 단축시키고, 학습이 어려운 작업에 대한 성능을 향상시키는 효과적인 방법입니다. 하지만, 이 경우에도 새로운 데이터에 대해 다시 훈련을 시켜야 한다는 단점이 있습니다.



<img src="/images/2024-02-18-Decomposing_DNN/image-20240320214812115.png" alt="image-20240320214812115" style="zoom:50%;" />

**두 번째 방식은 클래스별로 모델을 분해하는 것입니다.** 이 접근 방식은 특정 클래스에서 문제가 발생했을 때, 해당 클래스에 대응하는 모델의 부분만을 정상적인 모델의 해당 부분으로 교체할 수 있는 가능성을 열어줍니다. 그러나 모델은 클래스별로 명확하게 분해될 수 있는 구조로 설계되지 않아 이 방법이 쉽지 않습니다. 특히, 마지막 로짓(logit) 단계의 노드를 제외하고는, 모든 노드들이 각 클래스의 분류 작업에 공통적으로 기여합니다. 이는 모델 내의 파라미터들이 서로 복잡하게 연결되어 있기 때문입니다. 비록 클래스별로 모델을 명확하게 분해하는 것이 어렵긴 하지만, 이 방향으로의 탐구는 여전히 가치가 있으며, 가능한 한 클래스별로 모델을 분해해볼 수 있는 방법에 대해 아래에서 더 자세히 소개합니다.



### 클래스별 모델 분해의 유용성

이 논문에서는 클래스별로 모델을 분해할 수 있는 경우의 다양한 활용 예시들을 제안합니다.



![image-20240320215027941](/images/2024-02-18-Decomposing_DNN/image-20240320215027941.png)

**첫 번째로, 특정 클래스에서만 문제가 발생하는 경우, 해당 클래스에 대응하는 모델 부분을 정상 모델에서 교체하는 방법을 소개합니다.** 기존에는 추가 데이터를 학습시키는 방법 외에 해결책이 마땅치 않았지만, 이 방법을 통해 문제가 있는 부분만을 직접 교체함으로써 별도의 학습 없이도 문제를 해결할 수 있게 됩니다. 이는 학습에 소요되는 시간과 자원을 대폭 절약할 수 있는 매우 유익한 접근법입니다.



![image-20240320215049409](/images/2024-02-18-Decomposing_DNN/image-20240320215049409.png)

**두 번째로, 클래스별로 분해된 모델을 재조합하여 새로운 분류기를 생성할 수 있는 가능성을 탐색합니다.** 예를 들어, 0부터 9까지의 손글씨 숫자를 분류할 수 있는 딥 뉴럴 네트워크(DNN) 분류기가 있다고 가정하겠습니다. 만약 0과 1만을 구분하는 새로운 분류기가 필요하다면, 기존의 전이학습 방식으로는 앞단의 레이어를 재사용하고 마지막 레이어만 조정하여 0과 1에 대한 재학습을 진행해야 합니다. 그러나 이미 0부터 9까지를 분류할 수 있는 능력이 있는 분류기에서 0과 1을 다시 학습시키는 것은 비효율적입니다. 클래스별로 모델을 분해할 수 있다면, 0과 1에 해당하는 모듈만을 선택하여 바로 이진 분류기를 구성할 수 있습니다. 더 나아가, 숫자와 알파벳을 분류하는 분류기를 조합하여 16진수를 분류할 수 있는 분류기를 만드는 것도 가능합니다.



### 모델 분해 순서

![image-20240320172820373](/images/2024-02-18-Decomposing_DNN/image-20240320172820373.png)

모델을 각 클래스별로 분해하는 과정은 **CI**(Concern Identification), **TI**(Tangling Identification), 그리고 **CM**(Concern Modularization)의 세 단계를 거쳐 진행됩니다. 이 과정을 통해, 각 클래스별 이진 분류기 형태의 모듈로 모델을 분해합니다. 각 단계에서 수행하는 작업을 자세히 살펴보겠습니다.



#### **CI(Concern Identification)**

이 단계에서는 해당 클래스와 관련 없는 노드들을 식별하여 제거합니다. 클래스와 관련 없는 노드란, ReLU 활성화 함수를 통과했을 때 활성화 값이 0이 되어 아무런 영향을 미치지 않는 노드를 의미합니다. 만약 어떤 클래스에 대해서 특정 노드가 항상 0으로 활성화되어 기여하지 않는다면, 해당 노드는 그 클래스를 분류하는 데 있어 불필요하므로 제거됩니다.



<img src="/images/2024-02-18-Decomposing_DNN/image-20240320221744930.png" alt="image-20240320221744930" style="zoom:50%;" />

위의 유사코드에서 자세한 동작을 확인할 수 있습니다. CI 단계의 작업은 입력 데이터를 통과시킨 후, 모든 레이어에서 노드를 순회하면서 해당 노드의 활성화가 0인 경우, 해당 노드와 연결된 가중치들을 0으로 설정하여 제거하는 과정입니다.



#### **TI(Tangling Identification)**

CI 단계를 통해 해당 클래스에 반응하지 않는 가중치를 제거한 후, 모델이 이진 분류기로서 기능을 완벽하게 수행한다고 확신할 수 없습니다. **그 이유는, 해당 클래스가 아닌 다른 클래스의 예시들을 정확하게 '아니오'라고 분류할 수 있는 능력이 충분히 갖춰졌다고 보장할 수 없기 때문입니다.** 이러한 능력의 부재는 모델의 분류 효율성을 저하시킬 수 있습니다. 따라서, TI(Tangling Identification) 과정을 통해 이러한 능력을 보완하고 강화해야 합니다. 이 과정을 통해, 해당 클래스에 속하지 않는 예시들에 대해 모델이 '아니오'라고 분류할 수 있는 능력을 회복시키는 것이 목적입니다.



<img src="/images/2024-02-18-Decomposing_DNN/image-20240320221906856.png" alt="image-20240320221906856" style="zoom:50%;" />

**TI(Tangling Identification) 단계에서는 해당 클래스에 속하지 않는 다른 클래스들의 예시를 모델에 입력했을 때 반응을 보이는, 즉 활성화값이 0이 아닌 노드들의 앞뒤로 연결된 가중치를 다시 활성화시킵니다.** 이 과정을 통해 해당 클래스가 아님을 구별하는 능력을 강화시킵니다. 간단히 말해, CI 단계에서는 불필요한 가중치를 제거하는 반면, TI 단계에서는 클래스 간 구별 능력을 회복하기 위해 필요한 가중치를 복원합니다. 목표는 해당 클래스의 분류에 필수적인 가중치만을 최대한 보존하는 것입니다. 이를 위해 CI와 TI의 작업 비율을 적절히 조절하는 것이 중요합니다. 저자는 이 과정을 효과적으로 수행하기 위한 네 가지 접근법을 제안합니다.



1. **TI-I(Tangling Identification-Imbalance)**

   <img src="/images/2024-02-18-Decomposing_DNN/image-20240320222937988.png" alt="image-20240320222937988" style="zoom:50%;" />
   
   **TI-I 과정은 특정 클래스를 분류하기 위해 양성 예시와 음성 예시에 대해 다른 접근 방식을 적용합니다.** 여기서 '양성 예시'란 분류 대상 클래스에 속하는 샘플을 의미하며, '음성 예시'는 해당 클래스에 속하지 않는 샘플을 가리킵니다. 이 과정에서 양성 예시에 대해서는 CI(가중치 제거) 작업을 수행하고, 음성 예시에 대해서는 TI(가중치 복원) 작업을 진행합니다.
   
   '음성 예시'가 일반적으로 더 많은 상황에서 'imbalence'라는 용어가 사용되기도 하지만, 이 용어가 선택된 주된 이유는 실험에서의 예시 간 불균형 의도적으로 부여하는데에 있습니다. 실험자는 임의로 데이터의 비율을 불균형하게 설정합니다. 예를 들어, 양성 예시를 1000개로 설정하고, 각 클래스별 음성 예시는 단 1개씩으로 설정하는 등의 방식을 취합니다. 이러한 방식은 데이터 세트 내에서 양성 예시와 음성 예시 간의 극단적인 불균형을 의도적으로 만들어, 특정 실험 목적을 달성하기 위한 것입니다.



2. **TI-PN(Tangling Identification-Punish Negative Examples)**

   **TI-PN 접근 방식에서는 양성 예시와 음성 예시의 비율을 동일하게 조정하여 CI(가중치 제거)와 TI(가중치 복원) 작업을 수행합니다.** 예를 들어, CI 작업을 위한 양성 예시가 100개 있다고 할 때, 음성 클래스가 9개인 경우 각 클래스별로 11개씩 예시를 선택해, 총 99개의 음성 예시에 대해 TI 작업을 진행합니다. 또한, 알고리즘 2에는 18번째 줄이 추가되어 있으며, 이 부분에서는 소프트맥스 함수를 통과한 마지막 노드의 확률 값이 0.01% 이상일 경우에만 가중치를 복원합니다. 이는 기존에 0 초과 값에 대해 가중치를 복원하던 기준을 0.01%로 상향 조정함으로써, 실제로 가중치를 복원하는 경우의 수를 더 엄격하게 제한한다는 의미입니다. 이로 인해 가중치 복원이 더 적게 이루어지게 되어 모델의 효율성과 정확성을 높이는 데 기여할 수 있습니다.



3. **TI-HP(Tangling Identification-Higher Priority to Negative Examples)**

   **TI-HP 방식에서는 우선 음성 예시들에 대해 CI(가중치 제거) 작업을 진행하고, 그 다음으로 양성 예시에 대해서는 TI(가중치 복원)을 수행합니다.** 이 접근법에서도 TI-PN과 같이 양성 예시와 음성 예시의 비율을 균형 있게 유지합니다. 하지만, 이전 방식과는 다르게, TI-HP에서는 음성 예시에 대해 가지치기를 우선적으로 수행합니다. 이는 음성 예시를 우선 처리함으로써, 기존 방식에서 양성 예시에 적용되었던 가지치기 접근법을 음성 예시에 적용한 것으로, 결과적으로 음성 예시에 더 높은 우선순위를 부여하는 방식입니다. 이러한 변화는 모델의 학습 과정에서 음성 데이터의 처리를 강조하며, 전체적인 분류 성능의 균형을 잡는데 기여할 수 있습니다.



4. **TI-SNE(Tangling Identification-Strong Negative Edges)**

   **TI-SNE 방식에서도 TI-PN과 같이 양성 예시에 대해서는 CI(가중치 제거)를 수행하고, 음성 예시에 대해서는 TI(가중치 복원)를 진행합니다.** 하지만 차별점은 소프트맥스 함수를 통과한 마지막 노드의 확률 값을 기준으로 가중치를 복원하는 기준에 있습니다. TI-SNE에서는 이 확률 값이 0.01%가 아닌, 50% 이상일 때만 가중치를 복원합니다. 이는 가중치를 복원하는 기준을 훨씬 엄격하게 적용함을 의미하며, 결과적으로 가중치 복원이 이루어지는 경우가 훨씬 줄어들게 됩니다. 이와 같은 접근 방식은 모델이 더 확실한 경우에만 가중치를 복원하도록 하여, 분류 성능의 정확성을 높이려는 의도를 반영합니다.



#### CM(Concern Modularization)

CI와 TI 과정을 거치면, 특정 클래스를 이진 분류하는 데 중요한 가중치들이 선별됩니다. 그러나 이 과정만으로는 완전한 이진 분류기의 형태를 갖추지 못합니다. 그 이유는 여러 음성 클래스로 향하는 가중치 경로가 여전히 존재할 수 있기 때문입니다. 이러한 문제를 해결하기 위해, 다양한 음성 클래스로의 가중치 경로를 하나로 통합하는 과정이 필요합니다. 이를 위해 CM(Concern Mudularization) 단계가 도입됩니다. **CM 단계에서는 이진 분류기의 구조를 명확히 하기 위해 여러 음성 클래스 가중치 경로를 하나로 결합하는 작업을 수행합니다.**



1. **CM-C(Concern Modularization-Channeling)**

   <img src="/images/2024-02-18-Decomposing_DNN/image-20240321145852440.png" alt="image-20240321145852440" style="zoom:50%;" />

   **CM-C**(Concern Modulartization-Channeling) 과정은 매우 직관적입니다. 이 과정은 음성 클래스로 향하는 가중치들을 단일화하는 작업을 포함합니다. 예를 들어, 만약 우리가 0번 클래스를 대상으로 하는 이진 분류기를 만들고자 한다면, 1번 클래스로 향하는 모든 가중치를 특정 마지막 노드에 집중시킵니다. 또한, 1번부터 9번 클래스 중 하나가 양성 클래스로 정의된다면, 나머지 클래스들은 자동적으로 0번 클래스를 음성으로 구분하는 데 사용되는 가중치들로 집약됩니다. 이 가중치들을 통합하는 과정에서는 단순히 가중치들의 평균을 취하여 하나의 새로운 가중치로 합쳐줍니다. 이렇게 함으로써, 음성 클래스를 향하는 가중치 경로를 간소화하여 모델의 구조를 더 명확하게 하고, 계산 효율성을 높일 수 있습니다.



2. **CM-RIE(Remove Irrelevant Edges)**

   <img src="/images/2024-02-18-Decomposing_DNN/image-20240321151254245.png" alt="image-20240321151254245" style="zoom:50%;" />

   CM_RIE(Remove Irrelevant Edges) 과정에서는 CM-C(Concern Modularization-Channeling)의 단계에 앞서 추가적인 작업을 수행합니다. **이 추가적인 작업은 바로 마지막 레이어의 이전 레이어, 즉 소프트맥스 함수가 적용되는 레이어의 바로 이전의 마지막 히든 레이어에서 특정 노드들을 제거하는 것입니다.** 이 과정을 통해, 모델의 복잡도를 줄이고 효율성을 높이며, 결국 더 명확하고 간결한 모듈 구조를 형성할 수 있습니다. 노드 제거는 해당 노드들이 최종 분류 결정에 미치는 영향을 평가하여, 상대적으로 중요도가 낮거나 불필요한 정보를 전달하는 노드들을 대상으로 이루어집니다. 이렇게 함으로써, 모델이 최종 출력 단계로 넘어가기 전에, 더욱 집중적이고 효과적인 정보 처리가 가능하도록 합니다.

   **마지막 히든 레이어에서 진행하는 작업은 음성 클래스로만 연결되는 가중치를 가진 노드들을 찾는 것입니다. 발견된 이 노드들의 가중치는 평균을 내어 단일 가중치로 합칩니다.** 예를 들어, 1번 클래스를 분류하기 위한 이진 분류기에서 마지막 히든 레이어의 특정 노드가 0번, 3번, 4번 클래스에만 가중치를 연결한다면, 이 가중치들은 평균을 내어 하나로 합쳐지게 됩니다. 이렇게 합쳐진 가중치는 0번 클래스를 가리키는 단일 가중치로 남습니다.

   만약 이와 같은 특성을 가진 노드들이 여러 개 있을 경우, 이들은 하나의 노드로 통합됩니다. 예를 들어, 마지막 히든 레이어의 h1, h3, h4 노드가 이 조건에 해당한다면, 이들의 가중치 경로는 모두 h1 노드로 재조정됩니다. 문제는 h3과 h4 노드로 들어오는 가중치의 연결이 끊기게 된다는 점입니다. 그러나, 이 문제 역시, 가중치들의 방향을 h1 노드로 재조정함으로써 해결됩니다. 





## 실험 결과

이 논문에서는 정확도와 자카드 지수(Jaccard Index)라는 두 가지 평가 지표를 활용합니다. 정확도는 분석 방법론의 필수적인 평가 지표로, 모델의 성능을 측정하기 위해 사용됩니다. 한편, 자카드 지수는 모델이 각 클래스를 얼마나 잘 분해해냈는지 판단하기 위한 지표로 채택되었습니다. 이는 모델이 클래스 간 분해를 명확하게 해낼수록 모델 간 유사도가 낮아져야 한다는 저자의 가정을 반영한 것입니다.

저자는 클래스별 모듈을 분해하고, 이들 모듈을 조합하여 새로운 분류기를 만들기 전에, 다양한 모듈 분해 방법들(TI-I, TI-HP, TI-SNE, TI-PN, CM-C, CM-RIE)에 대한 평가를 제시합니다.



### 모듈 분해 방법 평가

![image-20240323162413665](/images/2024-02-18-Decomposing_DNN/image-20240323162413665.png)

자카드 지수(JI)를 살펴보면, **TI-HP** 방법을 사용했을 때 가장 낮은 값을 보입니다. 이는 해당 방법으로 모델이 가장 크게 다른 방식으로 분해되었다는 것을 의미합니다. 그러나 흥미롭게도, 이 방법의 정확도는 낮습니다. 일반적으로 모델이 다르게 분해되는 것은 바람직하지만, 그것이 높은 정확도와 함께 이루어져야 의미가 있습니다. 낮은 정확도에서의 다른 분해는 긍정적인 결과로 해석하기 어렵습니다. 저자는 TI-HP 방법으로 모델을 분해했을 때 낮은 정확도가 나타난 이유를 분석합니다. 이 방식에서는 음성 예시들에 대한 업데이트를 진행한 후 양성 예시들에 대해 업데이트를 실행하는데, 이 과정에서 음성 예시의 정확도가 현저히 감소합니다. **이는 음성 예시를 분류하는 데 필요한 가중치들이 양성 예시를 분류하는 데 필요한 가중치 업데이트 과정에서 덮어쓰이기 때문입니다.** 다른 방식에서는 양성 예시에 대한 업데이트를 우선적으로 진행하고 음성 예시에 대한 업데이트를 이후에 수행하는 반면, TI-HP 방식에서는 이 순서가 반대로 진행되어 낮은 정확도의 결과를 초래한 것으로 분석됩니다.

**TI-PN** 방식을 적용한 결과를 분석해보면, 자카드 지수가 TI-HP 방식에 비해 더 높게 나타났습니다. 그럼에도 불구하고, **정확도는 여전히 낮은 편입니다.**

**TI-I와 TI-SNE** 방식은 음성 예시를 분류하는 데 필요한 가장 핵심적이고 강력한 가중치만을 회복시키는 접근 방식을 취합니다. **이 두 방식에서 정확도가 가장 높게 나타났습니다**. 반면, TI-PN에서 정확도가 낮게 나타난 것과 비교할 때, 음성 예시를 분류하는 데 필요한 가중치를 과도하게 회복시킬 경우 정확도가 오히려 감소할 수 있음을 확인할 수 있습니다. 

표의 우측 부분은 TI 단계에서 우수한 성능을 보였던 TI-I와 TI-SNE에 대해 두 가지 CM 알고리즘, **CM-C와 CM-RIE를 적용한 결과**를 보여줍니다. **대부분의 경우에서 CM-RIE를 적용했을 때 자카드 지수(JI)가 낮게 나타나며, 동시에 정확도가 높게 나타나는 것을 확인할 수 있습니다.**



### Intra-Dataset Reuse

![image-20240323164924709](/images/2024-02-18-Decomposing_DNN/image-20240323164924709.png)

**Intra-Dataset Reuse는 한 모델에서 분해하여 얻은 모듈들을 활용해 이진 분류기를 제작하는 상황입니다.** 논문의 초기 부분에서 언급되었듯이, 모델을 여러 모듈로 분해한 후, 이들 모듈을 사용하여 이진 분류기를 구성할 수 있다고 설명했습니다. 일반적으로 이와 같은 작업을 수행하려면, 모델을 새로 설계하고 학습시켜야 하는데, Intra-Dataset Reuse는 이러한 추가적인 학습 과정 없이도 가능하다는 점을 강조합니다. 따라서 연구에서는 실제로 모듈을 조합하여 만든 이진 분류기와 새롭게 학습시킨 이진 분류기의 정확도를 비교 분석합니다.

표에서 MA는 기존 모델에서 분해한 모듈들을 이용해 구성한 이진 분류기를, TMA는 동일한 구조로 새롭게 설계하고 학습시킨 이진 분류기를 의미합니다. MNIST, FMNIST, KMNIST, EMNIST 각각의 데이터셋은 레이블이 10개 있으며, 이를 기반으로 가능한 모든 이진 분류기 조합은 총 45개입니다. 표에서 볼드체로 표시된 부분은 MA가 TMA보다 더 우수한 성능을 보인 조합들입니다. **MA가 다수의 경우에서 TMA보다 더 나은 성능을 달성했다는 것을 확인할 수 있습니다.**



### Inter-Dataset Reuse

![image-20240323165949127](/images/2024-02-18-Decomposing_DNN/image-20240323165949127.png)

**Inter-Dataset Reuse는 서로 다른 종류의 데이터셋에서 학습된 모델의 모듈을 활용하여 이진 분류기를 제작하고 사용하는 상황을 의미합니다.** 이 경우, 표에서는 MNIST와 EMNIST를 결합했을 때와 MNIST와 KMNIST를 결합했을 때의 결과를 보여줍니다. **대체로 TMA(새롭게 설계하고 학습시킨 이진 분류기)의 성능이 더 높은 것을 확인할 수 있습니다.** 특히, MNIST와 KMNIST를 결합했을 때는 TMA보다 성능이 높은 조합이 단 한 건도 없었습니다. 평균적으로 성능은 8.28% 낮았고, 중간값으로는 5.67% 낮게 나타났습니다.



![image-20240320215049409](/images/2024-02-18-Decomposing_DNN/image-20240320215049409.png)

MNIST(MN)와 EMNIST(EM)의 모듈을 활용하여 12진수 분류기를 제작하는 것 또한 Inter-Dataset Reuse에 해당됩니다. **이 경우 실제로 제작하여 실험했을 때, 새롭게 설계하고 학습시킨 이진 분류기(TMA)에 비해 8.05% 낮은 정확도를 기록했습니다.**



### Intra-Dataset Replacement

![image-20240323171924419](/images/2024-02-18-Decomposing_DNN/image-20240323171924419.png)

**Intra-Dataset Replacement는 특정 모듈을 같은 기능을 수행하는 다른 모듈로 교체하는 상황을 말합니다.** 예를 들어, MNIST 분류기에서 숫자 3을 구분하는 모듈을, 같은 숫자 3을 구분하는 다른 모듈로 교체하는 경우가 여기에 해당됩니다. 논문에서는 은닉층이 1개인 분류기의 특정 모듈을 은닉층이 4개인 분류기에서 동일한 클래스를 분류하는 모듈로 교체했을 때의 성능 변화를 측정했습니다. MNIST, KMNIST(KM), EMNIST(EM), FMNIST(FM)의 네 가지 경우에 대해 실험을 진행했고, 40개의 다양한 경우 중 10개에서는 성능이 약간 향상되었지만, **전체적으로 평균적으로 0.76%의 성능 하락과 중간값으로는 0.5%의 성능 하락이 관찰되었습니다.**



![image-20240320215027941](/images/2024-02-18-Decomposing_DNN/image-20240320215027941.png)

**논문은 특정 레이블에 대해 모델이 제대로 동작하지 않을 때, 해당 레이블을 처리하는 모듈을 다른 모듈로 교체하여 모델의 전체 성능을 향상시킬 수 있다고 언급합니다.** 이러한 상황을 구현하기 위해, 연구자들은 5번 레이블에 대해 데이터를 편향적으로 적게 제공하여 학습시킴으로써, 5번 레이블에 대한 성능이 특히 낮은 모델(정확도 96.82%)을 만들었습니다. 이후 이 모델에서 5번 레이블을 처리하는 모듈을 정상적인 성능의 모듈로 교체했을 때의 성능을 측정했습니다. 그 결과, **모델의 정확도가 1.84% 상승하여 98.66%에 도달했습니다.**



### Inter-Dataset Replacement

![image-20240323173016139](/images/2024-02-18-Decomposing_DNN/image-20240323173016139.png)

Inter-Dataset Replacement는 분류기 내 특정 모듈을 다른 데이터셋에서 온 모듈로 교체하는 상황을 지칭합니다. 예를 들어, MNIST 데이터셋을 사용한 분류기에서 숫자 3을 구분하는 모듈을, 알파벳 B를 구분하는 모듈로 교체하는 경우가 여기에 해당합니다. 성능 결과를 살펴보면, **대부분의 경우에서 성능이 하락한 것을 확인할 수 있습니다.** MNIST(MN)와 EMNIST(EM) 데이터셋 간 모듈을 교체했을 때는 평균적으로 1.62%의 성능 하락과 중간값으로는 1.16%의 성능 하락이 관찰되었습니다. MNIST(MN)와 KMNIST(KM) 데이터셋 간 모듈 교체에서는 평균으로는 5.44%의 성능 하락, 중간값으로는 5.40%의 성능 하락이 발생했습니다.





## 느낀 점

논문은 여러 DNN(Deep Neural Networks) 분해 알고리즘을 소개하고, 각 알고리즘의 성능을 비교하며, 저자가 설정한 다양한 상황에서 모듈 분해를 활용했을 때의 성능 변화를 자세히 제시하여 흥미롭습니다. 하지만, 걱정되는 부분은 유사코드에 오타가 다수 있고, 또, DNN을 전파할 때 활성화 함수를 적용하지 않는 점입니다. 깃허브에서 제공된 코드를 확인해도 활성화 함수를 별도로 적용하지 않는 것으로 보입니다. 이것이 실수인지 의도된 것인지, 아니면 활성화 함수를 적용했으나 논문에는 기재되지 않은 것인지 명확하지 않습니다. 만약 오류가 맞다면, 논문의 실험은 재수행되어야 할 것입니다.





#### 글을 끝마치며..

이 논문은 신경망을 분해하는 방법론을 다루고 있습니다. 내용 자체는 복잡하지 않지만, 논문의 설명 방식이 다소 불친절해 아이디어 이해하기까지 시간이 조금 걸렸던 것 같습니다.

이 글을 통해 논문에서 제시하는 아이디어를 보다 쉽게 이해하실 수 있기를 바랍니다! 오류가 있다면 언제든지 댓글란에 편하게 남겨주세요.





