---
layout: single

title:  "컴퓨터시스템 03: 기계 수준 프로그래밍 3: 프로시저"

categories: Paper

tag: [Computer, System, Assembly]

typora-root-url: ../

toc: true

author_profile: false

sidebar:
    nav: "docs"

# search: false
use_math: true

---



**글에 들어가기 앞서...**

이 포스팅은 서울시립대학교 인공지능학과 백형부 교수님의 '**컴퓨터시스템**' 강좌의 중간고사 이전 범위 수업 내용에 대한 정리를 담고 있습니다.



수업 자료 출처: ***Bryant and O'Hallaron, Computer Systems: A Programmer's Perspective, 3rd Edition***







# 기계 수준 프로그래밍 IV: 데이터

프로그램에서 데이터를 처리할 때, 배열과 구조체는 가장 기본적이고 중요한 데이터 구조입니다. 이러한 데이터 구조들이 어떻게 메모리에 저장되고, 어셈블리 언어에서는 이들을 어떻게 다루는지에 대해 살펴보겠습니다.





## 배열(Array)

C언어에서 배열은 일련의 동일한 타입의 데이터를 연속적으로 저장하는 자료 구조입니다. 배열의 각 요소는 인덱스로 참조되며, 인덱스는 0부터 시작합니다. C언어에서 배열과 관련된 기본적인 문법과 특징을 레퍼런스 중심으로 설명하겠습니다.



### 선언과 초기화

<img src="/images/2024-04-21-Computer_System_06/image-20240421144652228.png" alt="image-20240421144652228" style="zoom:50%;" />

**선언**: 배열을 선언할 때는 타입, 배열의 이름, 그리고 대괄호 안에 배열의 크기를 명시합니다. 예: `int val[5];`

**초기화**: 배열을 선언함과 동시에 특정 값으로 초기화할 수 있습니다. 예: `int val[5] = {1, 5, 2, 1, 3};`



### 포인터

C언어의 독특한 문법들 중 하나인데요, 배열 이름은 배열의 첫 번째 요소의 주소를 나타내는 포인터로 사용될 수 있어, 배열과 포인터는 밀접하게 연관되어 있습니다. 예를 들어, `int val[10];` 선언 후 `int *p = val;`로 `p`포인터에 `val` 배열의 시작 주소를 할당할 수 있습니다. 이후 `*(p + 3)`은 `val[3]`과 동일한 값을 참조합니다.



### 참조

<img src="/images/2024-04-21-Computer_System_06/image-20240421144453038.png" alt="image-20240421144453038" style="zoom:30%;" />

배열의 특정 요소에 접근하려면 배열 이름과 인덱스를 사용합니다. 예: `val[2]`는 `val` 배열의 세 번째 요소를 참조합니다.

배열의 이름은 배열의 첫 번째 요소를 가리키는 포인터로 사용될 수 있습니다. 따라서, `val[2]`는 `*(val + 2)`와 동일합니다.



![image-20240421145219873](/images/2024-04-21-Computer_System_06/image-20240421145219873.png)

`get_digit`은 배열 내의 특정 값을 인덱스를 사용하여 참조하는 함수입니다. 어셈블리 언어에서 이 함수의 코드를 분석해보면, 완전 메모리 주소 지정 방식을 사용하여 주소 계산을 수행하는 것을 볼 수 있습니다. 구체적으로, `%rdi`에 저장된 주소에 `%rsi`에 저장된 인덱스 값을 4배 한 값을 더하여, 그 결과 주소에 위치한 값을 참조합니다. 정리하면, `%rdi + 4 * %rsi`에 해당하는 메모리 주소의 값을 읽어오는 작업을 수행한다고 할 수 있겠습니다.



<img src="/images/2024-04-21-Computer_System_06/image-20240421145810777.png" alt="image-20240421145810777" style="zoom:50%;" />

이 예시에서는 배열의 모든 원소에 1을 더하는 작업을 수행합니다. 이 과정은 이전 예시와 매우 유사한 방식으로 진행됩니다.



### Multi-demensional (Nested) Arrays

중첩 배열(Nested Arrays)은 배열 내에 또 다른 배열이 포함되어 있는 형태를 말합니다. 이런 구조는 다차원 데이터를 저장하고 관리하는 데 유용합니다. 가장 흔한 예로는 2차원 배열이 있으며, 이는 행렬(matrix)이나 테이블(table) 형태의 데이터를 표현할 때 사용됩니다.



<img src="/images/2024-04-21-Computer_System_06/image-20240421150248493.png" alt="image-20240421150248493" style="zoom:50%;" />

예를 들어, `T A[R][C];`는 타입 `T`의 2차원 배열을 선언하는 방법입니다. 여기서 `R`은 행(row)의 수를, `C`는 열(column)의 수를 나타냅니다. 이 배열은 `R`개의 행과 `C`개의 열을 가진 그리드(grid)로 생각할 수 있으며, 각 셀(cell)에는 `T` 타입의 값이 저장됩니다.



```c
int matrix[3][4];
```

이 코드는 `int` 타입의 값을 저장할 수 있는 3행 4열의 2차원 배열을 선언합니다. 이 배열의 각 원소는 `matrix[i][j]` 형태로 접근할 수 있으며, `i`는 행의 인덱스, `j`는 열의 인덱스를 나타냅니다. 



<img src="/images/2024-04-21-Computer_System_06/image-20240421150839789.png" alt="image-20240421150839789" style="zoom:50%;" />

중첩 배열의 원소들은 메모리 상에 연속적으로 배치됩니다. 예를 들어, 3행 4열의 배열을 선언하면, 총 12개의 원소가 메모리에 순서대로 일렬로 배치됩니다. 이러한 원소들이 연속적으로 배치된다는 사실을 통해, 배열의 첫 번째 주소만 알면, 특정 인덱스에 위치한 원소에 접근하는 것이 가능합니다.



**중첩 배열 행 접근 코드 예시**

<img src="/images/2024-04-21-Computer_System_06/image-20240421151207272.png" alt="image-20240421151207272" style="zoom:50%;" />

이 코드는 특정 인덱스에 해당하는 행의 첫 번째 주소를 반환하는 함수 `get_pgh_zip`의 구현입니다. C 언어에서 함수 선언 앞에 `*` 기호가 붙어있는 것으로 보아, 이 함수가 주소를 반환하는 것이 목적임을 알 수 있는데요, 구체적으로, 이 함수는 `pgh` 배열에서 해당 인덱스에 위치한 행의 첫 번째 주소를 찾아 반환합니다.



**중첩 배열 원소 접근 코드 예시**

<img src="/images/2024-04-21-Computer_System_06/image-20240421151629375.png" alt="image-20240421151629375" style="zoom:50%;" />

행 접근 코드를 이해하고 나면, 배열 내 특정 원소에 접근하는 것은 매우 간단합니다. 기본적으로 행의 주소를 계산한 후, 함수의 추가 파라미터로 받은 `dig` 값을 더하는 방식입니다. 이 과정에서 `dig`에 해당하는 열의 오프셋을 더하고, 해당 자료형의 크기(여기서는 4바이트)를 곱하여 최종 주소를 계산합니다. 이렇게 하면 원하는 원소에 정확히 접근할 수 있습니다.

1. `leaq (%rdi,%rdi,4), %rax` - 이 명령어는 `index * 5`를 계산합니다. 이는 특정 행에 대한 오프셋을 구하기 위한 계산입니다.

2. `addl %rax, %rsi` - 계산된 행의 오프셋에 `dig` 값을 더합니다. `dig`는 추가적으로 함수에 전달된 파라미터로, 특정 열에 접근하기 위한 값입니다. 이로써 `5 * index + dig`의 결과를 얻게 됩니다.

3. `movl pgh(,%rsi,4), %eax` - 마지막으로, `pgh` 배열에서 계산된 위치의 원소를 메모리에서 읽어옵니다. 여기서 `%rsi`에 4를 곱하는 이유는 각 원소가 4바이트 크기를 가지기 때문입니다. 즉, `pgh + 4 * (5 * index + dig)` 위치의 주소에 해당하는 값을 `%eax`에 저장합니다.

   

### Multi-Level Array

<img src="/images/2024-04-21-Computer_System_06/image-20240421152041282.png" alt="image-20240421152041282" style="zoom:50%;" />

다중 레벨 배열(multilevel array)은 주소의 배열로 이해할 수 있습니다. 이 구조는 데이터를 계층적으로 구성하는 데 유용하며, 이를 통해 복잡한 데이터 구조를 효율적으로 관리할 수 있습니다. 위의 예시를 통해 설명하겠습니다.
